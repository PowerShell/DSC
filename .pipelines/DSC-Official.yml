name: DSC-Release-$(Build.BuildId)
trigger: none

pr:
  branches:
    include:
    - onebranch
    - release/v*

parameters:
  - name: OfficialBuild
    type: boolean
    default: false
  - name: PublishToStore
    type: boolean
    default: false

variables:
  - name: BuildConfiguration
    value: 'release'
  - name: PackageRoot
    value: '$(System.ArtifactsDirectory)/Packages'
  - name: WindowsContainerImage
    value: 'onebranch.azurecr.io/windows/ltsc2022/vse2022:latest'
  - name: Codeql.TSAEnabled
    value: true
  - name: templateFile
    value: ${{ iif ( parameters.OfficialBuild, 'v2/OneBranch.Official.CrossPlat.yml@onebranchTemplates', 'v2/OneBranch.NonOfficial.CrossPlat.yml@onebranchTemplates' ) }}
  - group: DSC-Rust.SDK
  - name: officialBuild
    value: ${{ parameters.OfficialBuild }}
  - name: PublishToStore
    value: ${{ parameters.PublishToStore }}

resources:
  repositories:
  - repository: onebranchTemplates
    type: git
    name: OneBranch.Pipelines/GovernedTemplates
    ref: refs/heads/main

extends:
  template: ${{ variables.templateFile }}
  parameters:
    release:
      category: NonAzure
    featureFlags:
      WindowsHostVersion:
        Disk: Large
        Version: 2022
        Network: KS1 # note that this property is sticky so commenting out will use the previous set one
# Currently can't be used as some NPM pkgs like tree-sitter-cli reach out to GitHub to get the actual zip pkg
#        Network: NetLock
    customTags: 'ES365AIMigrationTooling'
    globalSdl:
      disableLegacyManifest: true
      sbom:
        enabled: true
        packageName: Microsoft.DSC
      codeql:
        compiled:
          enabled: true
      asyncSdl: # https://aka.ms/obpipelines/asyncsdl
        enabled: true
        forStages: [Build]
        credscan:
          enabled: true
          scanFolder:  $(System.DefaultWorkingDirectory)
        binskim:
          enabled: true
        apiscan:
          enabled: false
        tsaOptionsFile: .config\tsaoptions.json

    stages:
    - stage: BuildAndSign
      displayName: Build Native Binaries
      dependsOn: []
      jobs:
      - job: SetPackageVersion
        displayName: Set PackageVersion
        pool:
          type: windows
          vmImage: windows-latest
        variables:
          repoRoot: '$(System.DefaultWorkingDirectory)\DSC'
          ob_sdl_tsa_configFile: '$(System.DefaultWorkingDirectory)\.config\tsaoptions.json'
          ob_outputDirectory: '$(Build.ArtifactStagingDirectory)'
          ob_sdl_sbom_enabled: false
          ob_signing_setup_enabled: false
          ob_sdl_codeql_compiled_enabled: false
        steps:
        - checkout: self
        - pwsh: |
            Write-Verbose -Verbose (Get-ChildItem '$(repoRoot)' | Out-String)
            $packageVersion = $(repoRoot)/packaging.ps1 -GetPackageVersion
            $vstsCommandString = "vso[task.setvariable variable=Version;isoutput=true]$packageVersion"
            Write-Host ("sending " + $vstsCommandString)
            Write-Host "##$vstsCommandString"
          name: Package
          displayName: Set Package Version
        - task: AzureCLI@2
          displayName: Get Az Token
          inputs:
            azureSubscription: PowerShell-CICD-Feed-Access
            scriptType: pscore
            scriptLocation: inlineScript
            inlineScript: |
              $token = az account get-access-token --query accessToken --resource 499b84ac-1321-427f-aa17-267ca6975798 -o tsv
              $vstsCommandString = "vso[task.setvariable variable=AzToken;isoutput=true]$token"
              Write-Host "Setting token"
              Write-Host "##$vstsCommandString"

      - job: BuildWin_x64
        dependsOn: SetPackageVersion
        variables:
          ob_sdl_tsa_configFile: '$(System.DefaultWorkingDirectory)\.config\tsaoptions.json'
          ob_outputDirectory: '$(Build.ArtifactStagingDirectory)'
          signSrcPath: '$(System.DefaultWorkingDirectory)\out'
          AzToken: $[ dependencies.SetPackageVersion.outputs['AzToken'] ]
          ob_sdl_sbom_enabled: true
          ob_signing_setup_enabled: true
          ob_sdl_codeql_compiled_enabled: true
        pool:
          type: windows
        steps:
        - template: .pipelines/DSC-Windows.yml@self
          parameters:
            buildName: x86_64-pc-windows-msvc
            signSrcPath: '$(signSrcPath)'
            PackageRoot: '$(PackageRoot)'
            aztoken: '$(AzToken)'
            rustSDK: '$(Rust.SDK)'

      - job: BuildWin_arm64
        dependsOn: SetPackageVersion
        variables:
          ob_sdl_tsa_configFile: '$(System.DefaultWorkingDirectory)\.config\tsaoptions.json'
          ob_outputDirectory: '$(Build.ArtifactStagingDirectory)'
          signSrcPath: '$(System.DefaultWorkingDirectory)\out'
          AzToken: $[ dependencies.SetPackageVersion.outputs['AzToken'] ]
          ob_sdl_sbom_enabled: true
          ob_signing_setup_enabled: true
          ob_sdl_codeql_compiled_enabled: true
        pool:
          type: windows
        steps:
        - template: .pipelines/DSC-Windows.yml@self
          parameters:
            buildName: aarch64-pc-windows-msvc
            signSrcPath: '$(signSrcPath)'
            PackageRoot: '$(PackageRoot)'
            aztoken: '$(AzToken)'
            rustSDK: '$(Rust.SDK)'

      - job: CreateMsixBundle
        dependsOn:
          - BuildWin_x64
          - BuildWin_arm64
        variables:
          ob_outputDirectory: '$(Build.ArtifactStagingDirectory)'
          ob_sdl_tsa_configFile: '$(System.DefaultWorkingDirectory)\.config\tsaoptions.json'
          ob_symbolsPublishing_enabled: true
          ob_symbolsPublishing_symbolsFolder: '$(System.DefaultWorkingDirectory)\DSC\bin'
          ob_symbolsPublishing_searchPattern: '**/*.pdb'
          ob_symbolsPublishing_indexSources: true
          ob_sdl_sbom_enabled: false
          ob_signing_setup_enabled: false
          ob_sdl_codeql_compiled_enabled: false
          ob_restore_phase: true
        pool:
          type: windows
        steps:
        - checkout: self
        - download: current
          artifact: drop_BuildAndSign_BuildWin_x64
          patterns: '*.msix'
        - download: current
          artifact: drop_BuildAndSign_BuildWin_arm64
          patterns: '*.msix'
        - pwsh: |
            Set-Location "$(System.DefaultWorkingDirectory)\DSC"
            $null = New-Item -ItemType Directory -Path "./bin/msix" -Force -ErrorAction Ignore
            Copy-Item "$(Pipeline.Workspace)/drop_BuildAndSign_BuildWin_x64/*.msix" ./bin/msix -Verbose
            Copy-Item "$(Pipeline.Workspace)/drop_BuildAndSign_BuildWin_arm64/*.msix" ./bin/msix -Verbose
            ./packaging.ps1 -PackageType msixbundle
            Copy-Item "$(System.DefaultWorkingDirectory)/DSC/bin/*.msixbundle" "$(ob_outputDirectory)"
          displayName: 'Create msixbundle'
          condition: succeeded()

      - job: SignMsixBundle
        condition: and(succeeded(), eq(variables.officialBuild, true))
        dependsOn: CreateMsixBundle
        variables:
          ob_outputDirectory: '$(Build.ArtifactStagingDirectory)'
          ob_sdl_sbom_enabled: false
          ob_signing_setup_enabled: true
          ob_sdl_codeql_compiled_enabled: false
        pool:
          type: windows
        steps:
        - task: DownloadPipelineArtifact@2
          inputs:
            buildType: 'current'
            artifact: drop_BuildAndSign_CreateMsixBundle
            itemPattern: |
              **/*.msixbundle
            targetPath: '$(Build.ArtifactStagingDirectory)/downloads'
          displayName: Download MsixBundle
        - task: onebranch.pipeline.signing@1
          displayName: Sign MsixBundle
          condition: succeeded()
          inputs:
            command: 'sign'
            signing_profile: 'Dynamic-WINMSAPP1ST'
            files_to_sign: '*.msixbundle'
            search_root: '$(Build.ArtifactStagingDirectory)/downloads'
        - pwsh: |
            Copy-Item "$(Build.ArtifactStagingDirectory)/downloads/*.msixbundle" "$(ob_outputDirectory)"
          displayName: 'Copy MsixBundle to output directory'

      - job: PrepareStorePublish
        dependsOn: ['SetPackageVersion', 'SignMsixBundle']
        condition: and(succeeded(), eq(variables.officialBuild, true), eq( variables.PublishToStore, true ))
        displayName: Prepare Microsoft Store Publish to output directory
        pool:
          type: windows
        variables:
          ob_outputDirectory: '$(Build.ArtifactStagingDirectory)'
          ob_sdl_sbom_enabled: false
          ob_signing_setup_enabled: false
          ob_sdl_codeql_compiled_enabled: false
          PackageVersion: $[ dependencies.SetPackageVersion.outputs['Package.Version'] ]
        steps:
        - pwsh: |
            Write-Verbose -Verbose (Get-ChildItem '$(System.DefaultWorkingDirectory)' | Out-String)
            $pdpPath = '$(System.DefaultWorkingDirectory)\.pipelines\store\PDP\en-US\PDP.xml'
            if (-not (Test-Path -Path $pdpPath)) {
              throw "PDP path '$pdpPath' does not exist. Cannot update PDP.xml."
            }

            $sbConfigPath = '$(System.DefaultWorkingDirectory)\.pipelines\store\SBConfig.json'
            if (-not (Test-Path -Path $sbConfigPath)) {
              throw "SBConfig path '$sbConfigPath' does not exist. Cannot update SBConfig.json."
            }

            $isPreRelease = '$(PackageVersion)' -like '*-*'
            $pdpContent = Get-Content -Path $pdpPath -Raw
            $appName = if ($isPreRelease) {
              'DesiredStateConfiguration-Preview'
            } else {
              'DesiredStateConfiguration'
            }
            $pdpContent = $pdpContent.Replace('$AppName$', $appName)
            Set-Content -Path $pdpPath -Value $pdpContent
            Write-Host "PDP.xml updated successfully with AppName: $appName"

            $sbConfigContent = Get-Content -Path $sbConfigPath -Raw
            $productId = "Microsoft.$appName"
            $sbConfigContent = $sbConfigContent.Replace('$ProductID$', $productId)
            Set-Content -Path $sbConfigPath -Value $sbConfigContent
            Write-Host "SBConfig.json updated successfully with ProductID: $productId"
          displayName: 'Prepare Store Publish Files'
        - download: current
          artifact: drop_BuildAndSign_SignMsixBundle
          patterns: '*.msixbundle'
        - task: MS-RDX-MRO.windows-store-publish.package-task.store-package@3
          displayName: Package for Store Submission
          inputs:
            serviceEndpoint: dsc-store
            sbConfigPath: '$(System.DefaultWorkingDirectory)\.pipelines\Store\SBConfig.json'
            sourceFolder: '$(Pipeline.Workspace)\drop_BuildAndSign_SignMsixBundle'
            contents: '*.msixbundle'
            outSBName: 'DesiredStateConfigurationStorePackage'
            pdpPath: '$(System.DefaultWorkingDirectory)\.pipelines\Store\PDP'
            pdpMediaPath: '$(System.DefaultWorkingDirectory)\.pipelines\Store\PDP-Media'
        - pwsh: |
            Get-Item -Path "$(System.DefaultWorkingDirectory)/SBLog.txt" -ErrorAction SilentlyContinue |
              Copy-Item -Destination "$(ob_outputDirectory)" -Verbose
          displayName: Upload Store Failure Log
          condition: failed()
        - pwsh: |
            $submissionPackageDir = "$(System.DefaultWorkingDirectory)/SBOutDir"
            $jsonFile = "$submissionPackageDir/DesiredStateConfigurationStorePackage.json"
            $zipFile = "$submissionPackageDir/DesiredStateConfigurationStorePackage.zip"

            if ((Test-Path $jsonFile) -and (Test-Path $zipFile)) {
              Write-Verbose -Verbose "Uploading StoreBroker Package files:"
              Write-Verbose -Verbose "JSON File: $jsonFile"
              Write-Verbose -Verbose "ZIP File: $zipFile"

              Copy-Item -Path $submissionPackageDir -Destination "$(ob_outputDirectory)" -Verbose -Recurse
            }

            else {
              Write-Error "Required files not found in $submissionPackageDir"
            }
          displayName: 'Upload StoreBroker Package'

      - job: BuildLinuxMusl
        dependsOn: SetPackageVersion
        variables:
          LinuxContainerImage: 'onebranch.azurecr.io/linux/ubuntu-2204:latest'
          PackageVersion: $[ dependencies.SetPackageVersion.outputs['Package.Version'] ]
          AzToken: $[ dependencies.SetPackageVersion.outputs['AzToken'] ]
          ob_outputDirectory: '$(Build.ArtifactStagingDirectory)'
          ob_linuxSymbolsPublishing_enabled: true
          ob_linuxSymbolsPublishing_symbolsFolder: '$(System.DefaultWorkingDirectory)/DSC/bin'
          ob_linuxSymbolsPublishing_searchPattern: '**/*.dbg'
        displayName: Linux-x64-musl
        pool:
          type: linux
        steps:
        - task: RustInstaller@1
          inputs:
            rustVersion: ms-stable
            toolchainFeed: $(Rust.SDK)
            additionalTargets: x86_64-unknown-linux-musl
          displayName: Install Rust
          env:
            ob_restore_phase: true
        - pwsh: |
            apt update
            apt -y install musl-tools rpm dpkg build-essential
            $header = "Bearer $(AzToken)"
            $env:CARGO_REGISTRIES_POWERSHELL_TOKEN = $header
            $env:CARGO_REGISTRIES_POWERSHELL_CREDENTIAL_PROVIDER = 'cargo:token'
            ./packaging.ps1 -Release -Architecture x86_64-unknown-linux-musl
            ./packaging.ps1 -PackageType tgz -Architecture x86_64-unknown-linux-musl -Release
            ./packaging.ps1 -PackageType rpm -Architecture x86_64-unknown-linux-musl -Release
            ./packaging.ps1 -PackageType deb -Architecture x86_64-unknown-linux-musl -Release
            Copy-Item ./bin/*.tar.gz "$(ob_outputDirectory)"
            Copy-Item ./bin/*.rpm "$(ob_outputDirectory)"
            Copy-Item ./bin/*.deb "$(ob_outputDirectory)"
          displayName: 'Build x86_64-unknown-linux-musl'
          condition: succeeded()

      - job: BuildLinuxArm64Musl
        dependsOn: SetPackageVersion
        variables:
          LinuxContainerImage: 'onebranch.azurecr.io/linux/ubuntu-2204-arm64:latest'
          PackageVersion: $[ dependencies.SetPackageVersion.outputs['Package.Version'] ]
          AzToken: $[ dependencies.SetPackageVersion.outputs['AzToken'] ]
          ob_outputDirectory: '$(Build.ArtifactStagingDirectory)'
          ob_linuxSymbolsPublishing_enabled: true
          ob_linuxSymbolsPublishing_symbolsFolder: '$(System.DefaultWorkingDirectory)/DSC/bin'
          ob_linuxSymbolsPublishing_searchPattern: '**/*.dbg'
        displayName: Linux-ARM64-musl
        pool:
          type: linux
          hostArchitecture: arm64
        steps:
        - task: RustInstaller@1
          inputs:
            rustVersion: ms-stable
            toolchainFeed: $(Rust.SDK)
            additionalTargets: aarch64-unknown-linux-musl
          displayName: Install Rust
          env:
            ob_restore_phase: true
        - task: AzureCLI@2
          displayName: Azure CLI
          inputs:
            azureSubscription: PowerShell-CICD-Feed-Access
            scriptType: pscore
            scriptLocation: inlineScript
            inlineScript: |
              az account show
        - pwsh: |
            $env:CC_aarch64_unknown_linux_musl='clang'
            $env:AR_aarch64_unknown_linux_musl='llvm-ar'
            $env:CARGO_TARGET_AARCH64_UNKNOWN_LINUX_MUSL_RUSTFLAGS="-Clink-self-contained=yes -Clinker=rust-lld"
            apt update
            apt -y install clang
            apt -y install llvm
            apt -y install musl-tools
            apt -y install musl-gcc
            #apt -y install gcc-multilib
            apt -y install libssl-dev
            apt -y install pkg-config
            apt -y install rpm
            apt -y install dpkg
            apt -y install build-essential
            msrustup default stable-aarch64-unknown-linux-musl
            if ((openssl version -d) -match 'OPENSSLDIR: "(?<dir>.*?)"') {
              $env:OPENSSL_LIB_DIR = $matches['dir']
            }
            $header = "Bearer $(AzToken)"
            $env:CARGO_REGISTRIES_POWERSHELL_TOKEN = $header
            $env:CARGO_REGISTRIES_POWERSHELL_CREDENTIAL_PROVIDER = 'cargo:token'
            ./packaging.ps1 -Release -Architecture aarch64-unknown-linux-musl
            ./packaging.ps1 -PackageType tgz -Architecture aarch64-unknown-linux-musl -Release
            ./packaging.ps1 -PackageType rpm -Architecture aarch64-unknown-linux-musl -Release
            ./packaging.ps1 -PackageType deb -Architecture aarch64-unknown-linux-musl -Release
            Copy-Item ./bin/*.tar.gz "$(ob_outputDirectory)"
            Copy-Item ./bin/*.rpm "$(ob_outputDirectory)"
            Copy-Item ./bin/*.deb "$(ob_outputDirectory)"
          displayName: 'Build aarch64-unknown-linux-musl'
          condition: succeeded()

      - job: BuildMac
        dependsOn: SetPackageVersion
        variables:
          PackageVersion: $[ dependencies.SetPackageVersion.outputs['Package.Version'] ]
          AzToken: $[ dependencies.SetPackageVersion.outputs['AzToken'] ]
          ob_outputDirectory: '$(Build.ArtifactStagingDirectory)'
        displayName: BuildMac
        pool:
          type: linux
          isCustom: true
          name: Azure Pipelines
          vmImage: 'macOS-latest'
        strategy:
          matrix:
            macOS x64:
              buildName: x86_64-apple-darwin
            macOS arm64:
              buildName: aarch64-apple-darwin
        steps:
        - task: RustInstaller@1
          inputs:
            rustVersion: ms-stable
            toolchainFeed: $(Rust.SDK)
            additionalTargets: $(buildName)
          displayName: Install Rust
          env:
            ob_restore_phase: true
        - task: AzureCLI@2
          displayName: Azure CLI
          inputs:
            azureSubscription: PowerShell-CICD-Feed-Access
            scriptType: pscore
            scriptLocation: inlineScript
            inlineScript: |
              az account show
        - pwsh: |
            $header = "Bearer $(AzToken)"
            $env:CARGO_REGISTRIES_POWERSHELL_TOKEN = $header
            $env:CARGO_REGISTRIES_POWERSHELL_CREDENTIAL_PROVIDER = 'cargo:token'
            Write-Verbose -Verbose "Building for $(buildName)"
            ./packaging.ps1 -Release -Architecture $(buildName)
            ./packaging.ps1 -PackageType tgz -Architecture $(buildName) -Release
            Copy-Item ./bin/*.tar.gz "$(ob_outputDirectory)"
            Write-Host "##vso[artifact.upload containerfolder=release;artifactname=release]$(ob_outputDirectory)/DSC-$(PackageVersion)-$(buildName).tar.gz"
          displayName: 'Build $(buildName)'
          condition: succeeded()

    - stage: ReleasePreparation
      dependsOn: BuildAndSign
      condition: and(succeeded(), ne(variables['Build.Reason'], 'Schedule'), eq(variables.officialBuild, true))
      jobs:
      - job: ReleasePreparationJob
        displayName: Release Preparation job
        pool:
          type: windows
        variables:
          ob_outputDirectory: '$(Build.ArtifactStagingDirectory)'
        steps:
        - download: current
          artifact: drop_BuildAndSign_BuildWin_x64
          patterns: '*.zip'

        - download: current
          artifact: drop_BuildAndSign_BuildWin_arm64
          patterns: '*.zip'

        - download: current
          artifact: drop_BuildAndSign_BuildLinuxArm64Musl
          patterns: |
            *.tar.gz
            *.rpm
            *.deb

        - download: current
          artifact: drop_BuildAndSign_BuildLinuxMusl
          patterns: |
            *.tar.gz
            *.rpm
            *.deb

        - download: current
          artifact: release ## this includes artifacts for macOS
          patterns: '**/*.tar.gz'

        - download: current
          artifact: drop_BuildAndSign_SignMsixBundle
          patterns: '*.msixbundle'

        - download: current
          artifact: drop_BuildAndSign_PrepareStorePublish
          condition: and(succeeded(), eq( variables.PublishToStore, true ))
          patterns: |
            *.zip
            *.json

        - pwsh: |
            Get-ChildItem "$(Pipeline.Workspace)" -Recurse -Include '*.zip', '*.tar.gz', '*.msixbundle', '*.rpm', '*.deb', '*.json' | ForEach-Object {
              Write-Host "Found artifact: $($_.FullName)"
            }
          displayName: List downloaded artifacts

        - pwsh: |
            $outputDir = "$(ob_outputDirectory)\releasePrep"
            if( -not (Test-Path -Path $outputDir)) {
              New-Item -ItemType Directory -Path $outputDir -Force -ErrorAction Ignore -Verbose
            }

            Write-Verbose -Verbose "Starting to copy"

            Get-ChildItem "$(Pipeline.Workspace)" -Recurse -Include '*.zip', '*.tar.gz', '*.msixbundle', '*.rpm', '*.deb', '*.json' | ForEach-Object {
              Copy-Item -Path $_.FullName -Destination $outputDir -Force -Verbose
            }

            Write-Verbose -Verbose "Copy completed"
          displayName: Copy artifacts to release area

    - stage: Validation
      dependsOn: ['ReleasePreparation']
      condition: and(succeeded(), ne(variables['Build.Reason'], 'Schedule'))
      jobs:
      - job: ValidationJob
        displayName: Validation job
        pool:
          type: agentless
        steps:
        - task: ManualValidation@0
          displayName: Wait for manual validation
          inputs:
            notifyUsers: $(Build.RequestedForEmail)
            instructions: Please validate the build artifacts before proceeding to release.
            timeoutInMinutes: 1440

    - stage: Release
      dependsOn: ['BuildAndSign', 'Validation', 'ReleasePreparation']
      condition: and(succeeded(), ne(variables['Build.Reason'], 'Schedule'), eq(variables.officialBuild, true))
      variables:
        - name: PackageVersion
          value: $[ stageDependencies.BuildAndSign.SetPackageVersion.outputs['Package.Version'] ]
        - name: ob_release_environment
          value: ${{ iif ( parameters.OfficialBuild, 'Production', 'Test' ) }}
      jobs:
      - job: ReleaseJob
        displayName: Release job
        pool:
          type: release
          os: windows
        templateContext:
          inputs:
            - input: pipelineArtifact
              artifactName: drop_ReleasePreparation_ReleasePreparationJob

        steps:
        - task: PowerShell@2
          displayName: Capture downloaded artifacts and Version for release
          inputs:
            targetType: 'inline'
            script: |
              Write-Verbose -Verbose "Release version: $(PackageVersion)"

              $artifacts = Get-ChildItem "$(Pipeline.Workspace)" -Recurse -Include '*.zip', '*.tar.gz', '*.msixbundle', '*.rpm', '*.deb'

              $artifacts | ForEach-Object {
                Write-Verbose -Verbose "Found artifact: $($_.FullName)"
              }

              $GitHubReleaseDirectory = New-Item -ItemType Directory -Path "$(Pipeline.Workspace)/GitHubRelease" -Force -ErrorAction Ignore
              Write-Host "##vso[task.setvariable variable=GitHubReleaseDirectory]$GitHubReleaseDirectory"
              $artifacts | ForEach-Object {
                Copy-Item -Path $_.FullName -Destination $GitHubReleaseDirectory -Force -Verbose
              }

              if (-not '$(PackageVersion)') {
                throw "PackageVersion variable is not set. Cannot proceed with release."
              }

              $packageVersion = '$(PackageVersion)'
              if ($packageVersion -like '*-*') {
                Write-Verbose -Verbose "Pre-release version detected: $packageVersion"
                Write-Host "##vso[task.setvariable variable=IsPreRelease]true"
              }
              else {
                Write-Verbose -Verbose "Stable release version detected: $packageVersion"
                Write-Host "##vso[task.setvariable variable=IsPreRelease]false"
              }

              $githubReleaseVersion = "v$packageVersion"
              Write-Verbose -Verbose "GitHub Release version: $githubReleaseVersion"
              Write-Host "##vso[task.setvariable variable=GitHubReleaseVersion]$githubReleaseVersion"

              $appId = if ('$(PackageVersion)' -like '*-*') {
                '9PCX3HX4HZ0Z'
              } else {
                '9NVTPZWRC6KQ'
              }
              Write-Verbose -Verbose "App ID for Store submission: $appId"
              Write-Host "##vso[task.setvariable variable=AppID]$appId"

        - task: GitHubRelease@1
          displayName: Create GitHub release
          inputs:
            gitHubConnection: github.com_SteveL-MSFT
            repositoryName: PowerShell/DSC
            target: main
            action: create
            assets: |
              $(GitHubReleaseDirectory)\*.zip
              $(GitHubReleaseDirectory)\*.tar.gz
              $(GitHubReleaseDirectory)\*.msixbundle
              $(GitHubReleaseDirectory)\*.rpm
              $(GitHubReleaseDirectory)\*.deb
            addChangeLog: false
            tagSource: 'userSpecifiedTag'
            tag: '$(GitHubReleaseVersion)'
            isDraft: true
            isPreRelease: '$(IsPreRelease)'

        - task: MS-RDX-MRO.windows-store-publish.publish-task.store-publish@3
          displayName: 'Publish StoreBroker Package (Stable/LTS)'
          condition: and(succeeded(), eq( variables.PublishToStore, true ), eq( variables.officialBuild, true ))
          inputs:
            serviceEndpoint: dsc-store
            appId: '$(AppID)'
            inputMethod: JsonAndZip
            jsonPath: '$(Pipeline.Workspace)\DesiredStateConfigurationStorePackage.json'
            zipPath: '$(Pipeline.Workspace)\DesiredStateConfigurationStorePackage.zip'
            numberOfPackagesToKeep: 2
            jsonZipUpdateMetadata: true
            targetPublishMode: 'Manual'

    - stage: ReleaseUniversalPackage
      dependsOn: ['BuildAndSign','Release']
      condition: and(succeeded(), ne(variables['Build.Reason'], 'Schedule'), eq(variables.officialBuild, true))
      variables:
        - name: PackageVersion
          value: $[ stageDependencies.BuildAndSign.SetPackageVersion.outputs['Package.Version'] ]
      jobs:
      - job: ReleaseUniversalPackageJob
        displayName: Release Universal Package job
        pool:
          type: windows
        variables:
          ob_outputDirectory: '$(Build.ArtifactStagingDirectory)'
        steps:
        - download: current
          artifact: drop_ReleasePreparation_ReleasePreparationJob

        - pwsh: |
            $releasePrepPath = "$(Pipeline.Workspace)/drop_ReleasePreparation_ReleasePreparationJob/releasePrep"
            if (-not (Test-Path -Path $releasePrepPath)) {
              throw "Release preparation path '$releasePrepPath' does not exist."
            }

            $windowsFiles = Get-ChildItem -Path $releasePrepPath -Recurse -Include '*.zip'
            if ($windowsFiles.Count -eq 0) {
              throw "No Windows .zip files found in '$releasePrepPath'. Cannot proceed with Universal Package creation."
            }

            $linuxFiles = Get-ChildItem -Path $releasePrepPath -Recurse -Include '*linux.tar.gz'
            if ($linuxFiles.Count -eq 0) {
              throw "No Linux .tar.gz files found in '$releasePrepPath'. Cannot proceed with Universal Package creation."
            }

            $macosFiles = Get-ChildItem -Path $releasePrepPath -Recurse -Include '*darwin.tar.gz'
            if ($macosFiles.Count -eq 0) {
              throw "No macOS .tar.gz files found in '$releasePrepPath'. Cannot proceed with Universal Package creation."
            }

            $windowsDirectory = New-Item -ItemType Directory -Path "$releasePrepPath/windows" -Force -ErrorAction Ignore
            Write-Host "##vso[task.setvariable variable=WindowsDirectory]$($windowsDirectory.FullName)"

            $linuxDirectory = New-Item -ItemType Directory -Path "$releasePrepPath/linux" -Force -ErrorAction Ignore
            Write-Host "##vso[task.setvariable variable=LinuxDirectory]$linuxDirectory"

            $macosDirectory = New-Item -ItemType Directory -Path "$releasePrepPath/macos" -Force -ErrorAction Ignore
            Write-Host "##vso[task.setvariable variable=MacOSDirectory]$macosDirectory"

            $windowsFiles | ForEach-Object {
              Move-Item -Path $_.FullName -Destination $windowsDirectory.FullName -Force -Verbose
            }

            $linuxFiles | ForEach-Object {
              Move-Item -Path $_.FullName -Destination $linuxDirectory.FullName -Force -Verbose
            }

            $macosFiles | ForEach-Object {
              Move-Item -Path $_.FullName -Destination $macosDirectory.FullName -Force -Verbose
            }

          displayName: Prepare files for Universal Package

        - task: AzureCLI@2
          displayName: Publish Windows - Universal Package
          inputs:
            azureSubscription: PS-PS-DSC-UniversalFeed
            scriptType: pscore
            scriptLocation: inlineScript
            inlineScript: |
              $packageVersion = '$(PackageVersion)'

              if (-not $packageVersion) {
                throw "PackageVersion variable is not set. Cannot proceed with publishing Universal Package."
              }
              Write-Verbose -Verbose "Universal Package version: $packageVersion"
              az artifacts universal publish --organization https://dev.azure.com/PowerShell --project PowerShell --feed PowerShell-Universal --name microsoft.dsc-windows --version $packageVersion --description "Microsoft Desired State Configuration (DSC) - Universal Package" --path "$(WindowsDirectory)" --scope project --verbose
          condition: succeeded()

        - task: AzureCLI@2
          displayName: Publish Linux - Universal Package
          inputs:
            azureSubscription: PS-PS-DSC-UniversalFeed
            scriptType: pscore
            scriptLocation: inlineScript
            inlineScript: |
              $packageVersion = '$(PackageVersion)'

              if (-not $packageVersion) {
                throw "PackageVersion variable is not set. Cannot proceed with publishing Universal Package."
              }
              Write-Verbose -Verbose "Universal Package version: $packageVersion"
              az artifacts universal publish --organization https://dev.azure.com/PowerShell --project PowerShell --feed PowerShell-Universal --name microsoft.dsc-linux --version $packageVersion --description "Microsoft Desired State Configuration (DSC) - Universal Package" --path "$(LinuxDirectory)" --scope project --verbose
          condition: succeeded()

        - task: AzureCLI@2
          displayName: Publish macOS - Universal Package
          inputs:
            azureSubscription: PS-PS-DSC-UniversalFeed
            scriptType: pscore
            scriptLocation: inlineScript
            inlineScript: |
              $packageVersion = '$(PackageVersion)'

              if (-not $packageVersion) {
                throw "PackageVersion variable is not set. Cannot proceed with publishing Universal Package."
              }
              Write-Verbose -Verbose "Universal Package version: $packageVersion"
              az artifacts universal publish --organization https://dev.azure.com/PowerShell/ --project PowerShell --feed PowerShell-Universal --name microsoft.dsc-macos --version $packageVersion --description "Microsoft Desired State Configuration (DSC) - Universal Package" --path "$(MacOSDirectory)" --scope project --verbose
          condition: succeeded()
